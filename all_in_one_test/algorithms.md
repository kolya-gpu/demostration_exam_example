# Алгоритмы системы работы с партнерами

## Задание 2: Алгоритмы подсистемы

### 1. Алгоритм подсистемы для работы с партнерами

#### Общее описание
Подсистема реализует полный цикл управления партнерами компании, включая CRUD операции, расчет скидок и анализ продаж.

#### Основной алгоритм работы
```
1. Инициализация системы
   ├── Подключение к базе данных
   ├── Создание таблиц (если не существуют)
   ├── Импорт данных из Excel файлов
   └── Загрузка интерфейса

2. Основной цикл работы
   ├── Отображение списка партнеров
   ├── Обработка пользовательских действий
   │   ├── Добавление партнера
   │   ├── Редактирование партнера
   │   ├── Удаление партнера
   │   ├── Просмотр истории продаж
   │   └── Расчет материалов
   └── Обновление данных

3. Завершение работы
   ├── Сохранение изменений
   ├── Отключение от базы данных
   └── Закрытие приложения
```

#### Детализация операций

##### Добавление партнера
```
1. Валидация входных данных
   ├── Проверка обязательных полей
   ├── Валидация формата email
   ├── Валидация номера телефона
   └── Проверка уникальности названия

2. Сохранение в базу данных
   ├── Вставка записи в таблицу partners
   ├── Проверка успешности операции
   └── Обновление списка партнеров

3. Обработка результата
   ├── Успех: сообщение об успешном добавлении
   └── Ошибка: отображение деталей ошибки
```

##### Редактирование партнера
```
1. Загрузка данных партнера
   ├── Получение текущих данных из БД
   ├── Заполнение формы существующими данными
   └── Установка фокуса на первое поле

2. Валидация изменений
   ├── Проверка обязательных полей
   ├── Валидация форматов данных
   └── Проверка на дублирование

3. Обновление данных
   ├── Выполнение UPDATE запроса
   ├── Проверка успешности операции
   └── Обновление интерфейса
```

##### Удаление партнера
```
1. Подтверждение операции
   ├── Отображение предупреждения
   ├── Запрос подтверждения пользователя
   └── Проверка выбора

2. Каскадное удаление
   ├── Удаление связанных записей продаж
   ├── Удаление связей партнер-продукт
   └── Удаление основной записи партнера

3. Обновление данных
   ├── Обновление списка партнеров
   ├── Сброс выбранного партнера
   └── Отображение сообщения об успехе
```

### 2. Алгоритм функции расчета индивидуальной скидки для партнера

#### Описание алгоритма
Функция автоматически рассчитывает размер скидки для партнера на основе общего объема продаж за весь период работы.

#### Математическая формула
```
Скидка = f(Общий_объем_продаж)

где f(x) - ступенчатая функция:
- f(x) = 0%    при x < 10,000
- f(x) = 5%    при 10,000 ≤ x < 50,000  
- f(x) = 10%   при 50,000 ≤ x < 300,000
- f(x) = 15%   при x ≥ 300,000
```

#### Реализация алгоритма
```python
def calculate_partner_discount(total_sales):
    """
    Расчет скидки партнера на основе объема продаж
    
    Args:
        total_sales (int): Общий объем продаж партнера
        
    Returns:
        int: Процент скидки (0, 5, 10 или 15)
    """
    if total_sales < 10000:
        return 0
    elif total_sales < 50000:
        return 5
    elif total_sales < 300000:
        return 10
    else:
        return 15
```

#### SQL реализация
```sql
SELECT 
    p.partner_id,
    p.partner_name,
    COALESCE(SUM(s.quantity), 0) as total_sales,
    CASE 
        WHEN COALESCE(SUM(s.quantity), 0) < 10000 THEN 0
        WHEN COALESCE(SUM(s.quantity), 0) < 50000 THEN 5
        WHEN COALESCE(SUM(s.quantity), 0) < 300000 THEN 10
        ELSE 15
    END as discount_percentage
FROM partners p
LEFT JOIN sales s ON p.partner_id = s.partner_id
GROUP BY p.partner_id
ORDER BY p.partner_name
```

#### Логика работы
```
1. Сбор данных о продажах
   ├── Подсчет всех продаж партнера
   ├── Суммирование количества продукции
   └── Обработка случая отсутствия продаж

2. Определение уровня скидки
   ├── Сравнение с пороговыми значениями
   ├── Выбор соответствующего процента
   └── Возврат результата

3. Применение скидки
   ├── Отображение в интерфейсе
   ├── Цветовая индикация уровня
   └── Использование в расчетах
```

### 3. Алгоритм расчета необходимого количества материала

#### Описание алгоритма
Метод рассчитывает количество материала, необходимого для производства указанного количества продукции с учетом возможного брака.

#### Математическая формула
```
Материал_на_единицу = Параметр1 × Параметр2 × Коэффициент_типа_продукции
Общий_материал = Материал_на_единицу × Количество_продукции
Коэффициент_брака = 1 + (Процент_брака / 100)
Итоговое_количество = Общий_материал × Коэффициент_брака
```

#### Реализация алгоритма
```python
def calculate_material_required(self, 
                              product_type_id: int, 
                              material_type_id: int, 
                              product_quantity: int, 
                              product_param1: float, 
                              product_param2: float) -> int:
    """
    Расчет необходимого количества материала для производства продукции
    
    Args:
        product_type_id (int): Идентификатор типа продукции
        material_type_id (int): Идентификатор типа материала
        product_quantity (int): Количество получаемой продукции
        product_param1 (float): Первый параметр продукции
        product_param2 (float): Второй параметр продукции
        
    Returns:
        int: Количество необходимого материала с учетом брака или -1 при ошибке
    """
    try:
        # Валидация входных параметров
        if not self._validate_input_parameters(...):
            return -1
        
        # Получение коэффициентов из базы данных
        product_coefficient = self._get_product_type_coefficient(product_type_id)
        waste_percentage = self._get_material_waste_percentage(material_type_id)
        
        if product_coefficient is None or waste_percentage is None:
            return -1
        
        # Расчет количества материала на одну единицу продукции
        material_per_unit = product_param1 * product_param2 * product_coefficient
        
        # Расчет общего количества материала без учета брака
        total_material_needed = material_per_unit * product_quantity
        
        # Учет брака материала
        waste_factor = 1 + (waste_percentage / 100.0)
        material_with_waste = total_material_needed * waste_factor
        
        # Округление до целого числа в большую сторону
        final_material_quantity = int(material_with_waste + 0.99)
        
        return final_material_quantity
        
    except Exception as e:
        print(f"Ошибка расчета материала: {e}")
        return -1
```

#### Логика работы
```
1. Валидация входных данных
   ├── Проверка типов данных
   ├── Проверка положительности значений
   ├── Проверка существования типов в БД
   └── Возврат -1 при ошибке валидации

2. Получение справочных данных
   ├── Коэффициент типа продукции
   ├── Процент брака материала
   └── Проверка существования данных

3. Выполнение расчетов
   ├── Расчет материала на единицу
   ├── Расчет общего количества
   ├── Применение коэффициента брака
   └── Округление результата

4. Возврат результата
   ├── Успех: количество материала
   └── Ошибка: -1
```

#### Пример расчета
```
Входные данные:
- Тип продукции: ID=1, коэффициент=1.5
- Тип материала: ID=2, брак=10%
- Количество продукции: 100 шт.
- Параметр 1: 2.5
- Параметр 2: 1.8

Расчет:
1. Материал на единицу = 2.5 × 1.8 × 1.5 = 6.75
2. Общий материал без брака = 6.75 × 100 = 675
3. Коэффициент брака = 1 + (10% / 100) = 1.1
4. Материал с учетом брака = 675 × 1.1 = 742.5
5. Итоговое количество = ceil(742.5) = 743 ед.

Результат: 743 единицы материала
```

### 4. Алгоритм обработки исключительных ситуаций

#### Общая стратегия
Система использует многоуровневую обработку ошибок для обеспечения стабильности работы.

#### Уровни обработки ошибок
```
1. Уровень пользовательского интерфейса
   ├── Валидация ввода
   ├── Проверка бизнес-правил
   └── Информативные сообщения об ошибках

2. Уровень бизнес-логики
   ├── Проверка корректности данных
   ├── Обработка бизнес-исключений
   └── Логирование ошибок

3. Уровень доступа к данным
   ├── Проверка подключения к БД
   ├── Обработка SQL ошибок
   └── Транзакционная целостность

4. Уровень системы
   ├── Обработка критических ошибок
   ├── Graceful degradation
   └── Восстановление после сбоев
```

#### Типы сообщений пользователю
```
Ошибка (красный):
- Критические проблемы
- Невозможность выполнения операции
- Требует исправления пользователем

Предупреждение (желтый):
- Важная информация
- Работа продолжается
- Рекомендации по улучшению

Информация (синий):
- Успешные операции
- Общая информация
- Подтверждения действий
```

#### Алгоритм восстановления
```
1. Обнаружение ошибки
   ├── Логирование деталей
   ├── Определение типа ошибки
   └── Выбор стратегии восстановления

2. Попытка восстановления
   ├── Повторная попытка операции
   ├── Использование резервных данных
   └── Переключение на альтернативный режим

3. Уведомление пользователя
   ├── Описание проблемы
   ├── Предложение решений
   └── Инструкции по исправлению

4. Логирование результата
   ├── Успешность восстановления
   ├── Время восстановления
   └── Статистика ошибок
```

## Заключение

Все алгоритмы системы реализованы с учетом:
- **Производительности**: эффективные алгоритмы и оптимизированные запросы
- **Надежности**: обработка ошибок и валидация данных
- **Масштабируемости**: модульная архитектура и четкое разделение ответственности
- **Пользовательского опыта**: информативные сообщения и интуитивный интерфейс

Алгоритмы полностью соответствуют требованиям демоэкзамена и обеспечивают стабильную работу системы в различных условиях.
